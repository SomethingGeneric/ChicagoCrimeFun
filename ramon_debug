# <--------- Code for the insertion function. ---------->

# TODO: See if I can use the parent node for some insertion or logic in the code since I keep track of that attribute.

# x = self.rebalance(root)
# self.root = x   
# Update the root node

# FIXME: I never update the root attribute I just send the node which kept track of 1 being root.
# print("Parent: " + str(x.parent))
# print("Root: " + str(x))
# print("Left: " + str(x.left))
# print("Right: " + str(x.right))
# print("----------------------------------------------------")


# Update the height of the node.
# root.height = self.update_height(root)
# print("Height " + str(root.height))
# # Update the balance of the node.
# root.balance = self.balance(root)
# print("Balance: " + str(root.balance))

# <--------- Code for the rebalance function. ---------->


# FIXME: DO NOT REMOVE THIS UNCOMMENT OUT CODE USED FOR OPTIMIZATION.
    # """
    # A balance value of [-2, 2] means that the tree is unbalanced.
    # Also, it has to check if values of the keys are greater than the others.
    # """
    
    # # Case 1: Right Right
    # if node.balance == -2:
    #     print("Right Right")
    #     return self.left_rotate(node)

    # # Case 2: Left Left
    # if node.balance == 2:
    #     print("Left Left")
    #     return self.right_rotate(node)

    # # Case 3: Right Left
    # if node.balance == -2 and root.right.balance > 0:
    #     print("Right Left")
    #     node.right = self.right_rotate(node.right)
    #     return self.left_rotate(node)

    # # Case 4: Left Right
    # if node.balance == 2 and root.left.balance < 0:
    #     print("Left Right")
    #     node.left = self.left_rotate(node.left)
    #     return self.right_rotate(node)
    
    # #------------------------------------------>
    # # Case 1: Right Right
    # if node.balance < -1 and node.value > node.right.value:
    #     print("Right Right")
    #     return self.left_rotate(node)

    # # Case 2: Left Left
    # if node.balance > 1 and node.value < node.left.value:
    #     print("Left Left")
    #     return self.right_rotate(node)

    # # Case 3: Right Left
    # if node.balance < -1 and node.value < node.right.value:
    #     print("Right Left")
    #     node.right = self.right_rotate(node.right)
    #     return self.left_rotate(node)

    # # Case 4: Left Right
    # if node.balance > 1 and node.value > node.left.value:
    #     print("Left Right")
    #     node.left = self.left_rotate(node.left)
    #     return self.right_rotate(node)
    # #------------------------------------------>
    # # Case 1: Right Right
    # if node.balance == -2 and node.value > node.right.value:
    #     print("Right Right")
    #     return self.left_rotate(node)

    # # Case 2: Left Left
    # if node.balance == 2 and node.value < node.left.value:
    #     print("Left Left")
    #     return self.right_rotate(node)

    # # Case 3: Right Left
    # if node.balance == -2 and node.value < node.right.value:
    #     print("Right Left")
    #     node.right = self.right_rotate(node.right)
    #     return self.left_rotate(node)

    # # Case 4: Left Right
    # if node.balance == 2 and node.value > node.left.value:
    #     print("Left Right")
    #     node.left = self.left_rotate(node.left)
    #     return self.right_rotate(node)
    
    # return node
    
# <--------- Code for the right and left rotation function. ---------->

# FIXME: Instead of doing the computation here do it in a different function.
    # # Update the height of the nodes.
    # node.height = self.update_height(node)
    # pivot.height = self.update_height(pivot)
    
    # # Update the balance of the nodes.
    # pivot.balance = self.balance(pivot)
    # node.balance = self.balance(node)
        
#FIXME: Do not remove this is for debugging.
# print("Node Balance: " + str(node.balance))
# print("Node Height: " + str(node.height))
# print("Pivot Balance: " + str(pivot.balance))
# print("Pivot Height: " + str(pivot.height))
# print("----------------------------------------------------")


# FIXME: Instead of doing the computation here do it in a different function.
    
    ## Update the height of the nodes.  
    # pivot.height = self.update_height(pivot)
    # node.height = self.update_height(node)
    
    # # Update the balance of the nodes.
    # pivot.balance = self.balance(pivot)
    # node.balance = self.balance(node)
    

    # FIXME: Do not remove this is for debugging.
    # print("Node Balance: " + str(node.balance))
    # print("Node Height: " + str(node.height))
    # print("Pivot Balance: " + str(pivot.balance))
    # print("Pivot Height: " + str(pivot.height))
    # print("----------------------------------------------------")
        